export type Language = 'th' | 'en';

export const dictionary = {
    th: {
        nav: {
            title: 'เรียนรู้ Next.js',
            subtitle: 'คอร์ส TypeScript แบบโต้ตอบ',
            home: 'หน้าหลัก',
            variables: 'ตัวแปร (Const/Let)',
            state: 'สถานะ (useState)',
            effects: 'ผลข้างเคียง (useEffect)',
            fetch: 'การดึงข้อมูล (Fetch)',
            axios: 'การดึงข้อมูล (Axios)',
            routing: 'Routing ( เส้นทาง )',
            rsc: 'Server vs Client',
            serverActions: 'Server Actions',
            context: 'Global State (Context)',
            cssLayout: 'CSS Layout (Flex/Grid)',
            cssResponsive: 'Responsive Design',
            cssAnimation: 'Animations & Styling',
            stateRedux: 'State: Redux Toolkit',
            stateZustand: 'State: Zustand',
            workshopPokemon: 'Workshop: Pokedex',
        },
        home: {
            title: 'ยินดีต้อนรับสู่การเรียนรู้ Next.js',
            subtitle: 'คู่มือแบบโต้ตอบสำหรับเรียนรู้แนวคิดพื้นฐานของ Next.js และ TypeScript เริ่มต้นจากเมนูทางซ้ายหรือเลือกหัวข้อด้านล่าง',
            start: 'เริ่มเรียน',
            topics: [
                {
                    title: "ตัวแปร (Variables)",
                    desc: "ทำความเข้าใจ const vs let และ type inference",
                },
                {
                    title: "การจัดการสถานะ (State)",
                    desc: "เรียนรู้วิธีใช้ useState สำหรับการโต้ตอบ",
                },
                {
                    title: "ผลข้างเคียง (Side Effects)",
                    desc: "เจาะลึก useEffect สำหรับ lifecycle events",
                },
                {
                    title: "Fetch API",
                    desc: "การดึงข้อมูลแบบ Native ใน Next.js",
                },
                {
                    title: "Axios",
                    desc: "การดึงข้อมูลที่มีประสิทธิภาพด้วย library Axios",
                },
                {
                    title: "Routing & Dynamic Routes",
                    desc: "การสร้างหน้าเว็บตามโครงสร้างโฟลเดอร์",
                },
                {
                    title: "Server vs Client Components",
                    desc: "ความแตกต่างระหว่างการทำงานฝั่ง Server และ Client",
                },
                {
                    title: "Server Actions",
                    desc: "การส่งข้อมูลฟอร์มแบบสมัยใหม่",
                },
                {
                    title: "Global State (Context)",
                    desc: "การจัดการข้อมูลที่ใช้ร่วมกันทั้งแอพ",
                },
                {
                    title: "CSS Layouts (Flex & Grid)",
                    desc: "การจัดหน้าเว็บด้วย Flexbox และ CSS Grid",
                },
                {
                    title: "Responsive Design",
                    desc: "ทำเว็บให้รองรับมือถือและหน้าจอทุกขนาด",
                },
                {
                    title: "Animations & Styling",
                    desc: "เพิ่มความสวยงามและการเคลื่อนไหวด้วย Tailwind",
                },
                {
                    title: "Redux Toolkit",
                    desc: "มาตรฐานอุตสาหกรรมสำหรับการจัดการ State ขนาดใหญ่",
                },
                {
                    title: "Zustand",
                    desc: "ทางเลือกใหม่ที่ง่าย เบา และไม่ต้องใช้ Provider",
                }
            ]
        },
        lessons: {
            variables: {
                title: 'ตัวแปร: const vs let',
                intro: 'ใน JavaScript สมัยใหม่ (ES6+) และ TypeScript เราแทบจะไม่ใช้ var แล้ว แต่จะใช้ const และ let แทน',
                constTitle: '1. คำสั่ง const',
                constDesc: 'const ย่อมาจาก "constant" หมายความว่าตัวแปรนี้จะไม่สามารถถูกกำหนดค่าใหม่ได้ ควรใช้เป็นค่าเริ่มต้นสำหรับค่าที่ไม่เปลี่ยนแปลง',
                constError: '❌ บรรทัดนี้จะเกิด Error: เพราะพยายามเปลี่ยนค่า const',
                letTitle: '2. คำสั่ง let',
                letDesc: 'ใช้ let เมื่อคุณต้องการกำหนดค่าใหม่ให้กับตัวแปรในภายหลัง เช่น ในลูปหรือการคำนวณ',
                typeTitle: '3. TypeScript & Type Inference',
                typeDesc: 'TypeScript นั้นฉลาด มักจะไม่ต้องระบุ type ถ้าระบุค่าเริ่มต้นไปแล้ว เรียกว่า Type Inference',
                currentVal: 'ค่าปัจจุบันของ demoConst:',
                increment: 'เพิ่มค่า',
                stateSim: 'ค่าปัจจุบัน (useState):',
                letVsStateTitle: 'ทำไม let ถึงไม่อัพเดทหน้าจอ?',
                letVsStateDesc: 'ลองกดปุ่ม "Update let" ดูสิ! ค่าใน Console จะเปลี่ยน แต่หน้าจอไม่เปลี่ยน เพราะ React จะไม่รู้ว่าต้อง Render ใหม่',
                letBtn: 'อัพเดท let (ดู Console)',
                stateBtn: 'อัพเดท State (UI เปลี่ยน)',
            },
            state: {
                title: 'การจัดการสถานะ: useState',
                intro: 'State คือหน่วยความจำของ Component เมื่อ State เปลี่ยน React จะ render component ใหม่',
                basicTitle: 'State พื้นฐาน (ตัวเลข)',
                inputTitle: 'การผูกค่า Input (ข้อความ)',
                complexTitle: 'State ซับซ้อน (Object)',
                complexDesc: 'เมื่ออัพเดท Object, ต้องคัดลอกค่าเดิมมาก่อนด้วย spread operator ...',
                placeholder: 'พิมพ์อะไรสักอย่าง...',
                youTyped: 'คุณพิมพ์ว่า:',
                updateName: 'อัพเดทชื่อ',
                arrayTitle: 'การจัดการ Array ใน State',
                arrayDesc: 'ห้ามใช้ .push() เด็ดขาด! ให้ใช้ Spread Operator (...) เพื่อสร้าง Array ใหม่แทน',
                arrayWarning: '⚠️ ห้ามทำ (ไม่ Render):',
                arrayCorrect: '✅ วิธีที่ถูก (Render):',
                btnAdd: '+ เพิ่ม',
                btnPop: '- ลบตัวหลัง',
                btnFilter: 'ลบ Index 1'
            },
            effects: {
                title: 'ผลข้างเคียง: useEffect',
                intro: 'useEffect เปรียบเสมือน "คนดูแล" ที่จะคอยทำสิ่งต่างๆ เมื่อ Component เริ่มทำงาน (Mount), มีการเปลี่ยนแปลง (Update), และเลิกทำงาน (Unmount) ใช้สำหรับดึงข้อมูล, จับเวลา, หรือเชื่อมต่อระบบภายนอก',
                timerTitle: '1. Dependencies & Logic (ตัวอย่าง Timer)',
                timerDesc: 'Effect นี้จะ "เริ่มทำงานใหม่" ทุกครั้งที่ค่าใน [ ] เปลี่ยน (ในที่นี้คือ isRunning) เมื่อ isRunning เป็น true มันจะตั้งเวลา setInterval',
                cleanTitle: '2. ฟังก์ชัน Cleanup (สำคัญมาก!)',
                cleanDesc: 'React จะเรียกฟังก์ชันที่ return ออกไปเมื่อ Effect ถูกทำลาย หรือก่อนจะรัน Effect รอบใหม่ เพื่อ "ล้างบาง" สิ่งที่ค้างอยู่ เช่น clearInterval หรือ removeEventListener',
                startTimer: 'เริ่มจับเวลา',
                pauseTimer: 'หยุดจับเวลา',
                mousePos: 'ตำแหน่งเมาส์',
                moveMouse: 'ลองขยับเมาส์ไปมา event listener ทำงานอยู่ขอบคุณ useEffect',
                realWorldTitle: 'ตัวอย่างการใช้งานจริง (Real World Use Cases)',
                autoSaveTitle: 'A. ระบบบันทึกอัตโนมัติ (Auto-Save with Debounce)',
                autoSaveDesc: 'useEffect จะถูกเรียกทุกครั้งที่คุณพิมพ์ แต่เราใช้ setTimeout เพื่อรอให้คนหยุดพิมพ์ก่อนค่อยบันทึก (Delay 1 วินาที) ถ้าพิมพ์แทรก Effect เก่าจะถูก Clean up และเริ่มนับเวลาใหม่',
                typing: 'กำลังพิมพ์...',
                saving: 'กำลังบันทึก...',
                saved: 'บันทึกเรียบร้อยเมื่อ',
                exchangeTitle: 'B. อัพเดทข้อมูลตามตัวแปร (Currency Converter)',
                exchangeDesc: 'ทุกครั้งที่เลือกสกุลเงินใหม่ (dependency เปลี่ยน) Effect จะวิ่งไปดึงค่าเงินใหม่ทันที',
                rate: 'อัตราแลกเปลี่ยน'
            },
            fetch: {
                title: 'การดึงข้อมูล: Native Fetch API',
                intro: 'Next.js รองรับการดึงข้อมูลทั้งฝั่ง server และ client ตัวอย่างนี้แสดงการดึงฝั่ง Client',
                patternTitle: 'รูปแบบ Client-Side Fetch',
                patternDesc: 'รูปแบบมาตรฐานประกอบด้วย 3 สถานะ: loading, error, และ data',
                liveDemo: 'ตัวอย่างจริง',
                fetchBtn: 'ดึงข้อมูล Users',
                fetching: 'กำลังดึงข้อมูล...',
                loading: 'กำลังโหลด...',
                clickToLoad: 'คลิกปุ่มเพื่อโหลดข้อมูล',
                error: 'เกิดข้อผิดพลาด:',
            },
            axios: {
                title: 'การดึงข้อมูล: Axios',
                intro: 'Axios คือ HTTP client ยอดนิยมที่ช่วยให้การ request ง่ายขึ้น รองรับ browser เก่าและแปลง JSON อัตโนมัติ',
                vsTitle: 'Axios vs Fetch',
                features: [
                    'แปลง JSON อัตโนมัติ: ไม่ต้องใช้ response.json()',
                    'จัดการ Error ดีกว่า: Reject promise ทันทีเมื่อเจอ 4xx/5xx',
                    'Interceptors: แทรก token หรือ config ได้ง่ายๆ',
                ],
                demoTitle: 'ตัวอย่าง Axios',
                fetchBtn: 'ดึงข้อมูล Posts',
                clickToLoad: 'คลิกปุ่มเพื่อดึงข้อมูลผ่าน Axios',
            },
            routing: {
                title: 'Routing: File-System Based',
                intro: 'Next.js ใช้ระบบไฟล์ในการกำหนด Route โฟลเดอร์ใน `app` จะกลายเป็น URL path โดยอัตโนมัติ',
                basicsTitle: 'พื้นฐาน Routing',
                basicsDesc: 'ไฟล์ `page.tsx` คือหน้าเว็บ ส่วน `layout.tsx` คือโครงร่างที่ใช้ร่วมกัน',
                dynamicTitle: 'Dynamic Routes [id]',
                dynamicDesc: 'ใช้วงเล็บเหลี่ยม `[id]` เพื่อสร้าง Route ที่รับค่า Dynamic เช่น `/blog/1` หรือ `/blog/2`',
                demoTitle: 'สาธิต Dynamic Route',
                clickToTest: 'คลิกเพื่อทดสอบลิงก์:',
                product: 'สินค้า'
            },
            rsc: {
                title: 'Server vs Client Components',
                intro: 'ใน Next.js (App Router) ทุก Component เป็น Server Component โดยค่าเริ่มต้น ยกเว้นคุณจะประกาศ `use client`',
                serverTitle: 'Server Component (Default)',
                serverDesc: 'ทำงานบน Server เท่านั้น เหมาะสำหรับดึงข้อมูล (Database/API) ข้อดีคือโค้ดไม่ส่งไปหา User (Bundle เล็ก)',
                clientTitle: 'Client Component',
                clientDesc: 'ใช้เมื่อต้องการ Interactivity (useState, useEffect, onClick) ต้องใส่บรรทัดบนสุดว่า "use client"',
                demo: 'ตัวอย่างการใช้งานจริง',
                serverLog: 'ข้อความนี้ log บน Server terminal',
                clientLog: 'ข้อความนี้ log บน Browser console',
            },
            serverActions: {
                title: 'Server Actions',
                intro: 'วิธีใหม่ในการจัดการ Form Submit เขียนฟังก์ชันที่รันบน Server แล้วเรียกใช้จาก `form action` ได้เลย ไม่ต้องสร้าง API endpoint',
                formTitle: 'แบบฟอร์ม Server Action',
                desc: 'ลองกรอกข้อมูลแล้วดูผลลัพธ์ ข้อมูลจะถูกส่งไปประมวลผลที่ Server เหมือนเวทมนตร์',
                label: 'ส่งข้อความถึง Server:',
                btn: 'ส่งข้อมูล',
                placeholder: 'พิมพ์ข้อความ...',
                success: 'Server ตอบกลับมาว่า: '
            },
            context: {
                title: 'Global State (Context API)',
                intro: 'เมื่อต้องการแชร์ข้อมูลให้หลายๆ Component ใช้ (เช่น User Auth, Theme, Language) เราใช้ Context API',
                desc: 'ตัวอย่างที่ชัดเจนที่สุดคือระบบ "เปลี่ยนภาษา" ที่คุณกำลังใช้อยู่นี้! มันใช้ Context Provider ครอบทั้ง App ไว้',
                demoTitle: 'Context Demo (User)',
                login: 'เข้าสู่ระบบ (จำลอง)',
                logout: 'ออกจากระบบ',
                welcome: 'ยินดีต้อนรับ, '
            },
            cssLayout: {
                title: 'Layout Masters: Flexbox & Grid',
                intro: 'หัวใจสำคัญของการจัดหน้าเว็บคือ Flexbox (แกนเดียว) และ Grid (สองแกน) Tailwind ทำให้เรื่องนี้ง่ายขึ้นมาก',
                flexTitle: 'Flexbox (การจัดเรียง)',
                flexDesc: 'ใช้ `flex` เพื่อเรียงของแนวนอนหรือแนวตั้ง จัดกึ่งกลางได้ง่ายๆด้วย `items-center` และ `justify-center`',
                gridTitle: 'CSS Grid (ตาราง)',
                gridDesc: 'ใช้ `grid-cols-3` เพื่อแบ่งพื้นที่เป็น 3 ส่วนเท่าๆ กัน เหมาะสำหรับ Gallery หรือ Dashboard',
                demoItem: 'กล่องที่'
            },
            cssResponsive: {
                title: 'Responsive & Mobile First',
                intro: 'Tailwind ใช้หลักการ Mobile First คือเขียน style ของมือถือก่อน แล้วค่อยเพิ่ม `md:` หรือ `lg:` สำหรับจอใหญ่',
                breakpointsTitle: 'จุดตัดหน้าจอ (Breakpoints)',
                breakpointsDesc: 'ลองย่อ/ขยายหน้าต่าง browser เพื่อดูการเปลี่ยนแปลงของกล่องด้านล่าง',
                mobile: 'มือถือ (Default)',
                tablet: 'แท็บเล็ต (md)',
                desktop: 'หน้าจอคอม (lg)',
                demoBox: 'ฉันเปลี่ยนขนาดได้!'
            },
            cssAnimation: {
                title: 'Animations & Styling',
                intro: 'เว็บไซต์ที่ดีต้องมีความ "มีชีวิตชีวา" การใส่ Transition และ Animation เล็กๆ น้อยๆ ช่วยให้ดูพรีเมียมขึ้น',
                hoverTitle: 'Hover & Transition',
                hoverDesc: 'ใช้ `transition-all` และ `hover:scale` เพื่อสร้างความรู้สึกลื่นไหลเวลานำเมาส์ไปชี้',
                pulseTitle: 'Keyframe Animations',
                pulseDesc: 'Tailwind มี animation พื้นฐานมาให้ เช่น `animate-bounce` หรือ `animate-pulse` เหมาะสำหรับสถานะ Loading',
                btnHover: 'ชี้ฉันสิ!',
                loading: 'กำลังโหลด...'
            },
            stateRedux: {
                title: 'Redux Toolkit & React Redux',
                intro: 'Redux คือมาตรฐานอุตสาหกรรมสำหรับการจัดการ State ที่ซับซ้อน เราใช้ Redux Toolkit (RTK) คู่กับ React Redux เพื่อเชื่อมต่อกับ React',
                concept: 'หลักการทำงาน (Flux Pattern)',
                conceptDesc: 'Store (แหล่งเก็บข้อมูล) -> Action (คำสั่ง) -> Reducer (คนแก้ไขข้อมูล) -> New State',
                pros: [
                    'คาดเดาได้ง่าย (Predictable)',
                    'เครื่องมือ debug เทพ (Redux DevTools)',
                    'มีโครงสร้างชัดเจน เหมาะกับทีมใหญ่'
                ],
                cons: [
                    'เขียนโค้ดเยอะ (Boilerplate)',
                    'ต้อง Wrap App ด้วย Provider',
                    'เรียนรู้ยากสำหรับมือใหม่'
                ],
                demoTitle: 'ตัวอย่าง 1: Real Code (RTK + Store)',
                demoDesc: 'ตัวอย่างการสร้าง Slice และ Store จริงๆ พร้อมเชื่อมต่อด้วย <Provider> และเรียกใช้ด้วย useSelector / useDispatch',
                value: 'ค่าปัจจุบัน:',
                inc: 'เบิ้ม (+)',
                dec: 'ลด (-)',
                reset: 'รีเซ็ต',
                globalTitle: 'ตัวอย่าง 2: Global User State',
                globalDesc: 'การจำลองข้อมูลผู้ใช้ (User Slice) ที่แสดงผลและแก้ไขได้จากคนละ Component เพื่อพิสูจน์ว่าเป็น Global State',
                cardTitle: 'การ์ดผู้ใช้ (User Card)',
                editTitle: 'แก้ไขข้อมูล (Edit Profile)',
                userName: 'ชื่อผู้ใช้',
                userRole: 'ตำแหน่ง',
                updateProfile: 'อัพเดทโปรไฟล์',
                note: '* สังเกตว่าเมื่อ Component A อัพเดทค่า -> Component B จะเปลี่ยนตามทันทีโดยไม่ต้องส่ง Props'
            },
            stateZustand: {
                title: 'Zustand',
                intro: 'Zustand ("สถานะ" ในภาษาเยอรมัน) เป็น library ที่มาแรงมาก เพราะง่าย เบา และใช้ Hook ล้วนๆ',
                concept: 'หลักการทำงาน',
                conceptDesc: 'สร้าง Store เป็น Hook แล้วเรียกใช้ที่ไหนก็ได้ ไม่ต้องมี Provider ครอบ!',
                pros: [
                    'โค้ดน้อยมาก (Minimal Boilerplate)',
                    'ไม่ต้องใช้ Context Provider',
                    'Render เฉพาะส่วนที่เปลี่ยน (Performance ดี)'
                ],
                cons: [
                    'อาจจะยืดหยุ่นเกินไปจนไม่มีมาตรฐาน (ถ้าไม่ตกลงกันในทีม)',
                    'Community ยังเล็กกว่า Redux'
                ],
                demoTitle: 'ตัวอย่าง Zustand Store',
                demoDesc: 'ลองจินตนาการว่าเรามี Store กลางสำหรับเก็บ "จำนวนหมี" ในป่า',
                bears: 'หมี',
                addBear: 'เพิ่มหมี',
                removeBear: 'ลดหมี',
                clear: 'ล้างหมด'
            },
            workshopPokemon: {
                title: 'Workshop: Pokedex App',
                intro: 'บทเรียนนี้จะนำทุกอย่างมารวมกัน: State, Effect, Axios และการจัดการข้อมูลที่ซับซ้อน เพื่อสร้างแอพค้นหา Pokemon',
                searchTitle: 'ค้นหา Pokemon',
                searchDesc: 'ใช้ Axios เพื่อดึงข้อมูลจาก PokeAPI โดยระบุชื่อหรือ ID',
                placeholder: 'พิมพ์ชื่อหรือ ID (เช่น pikachu, 1)',
                searchBtn: 'ค้นหา',
                randomBtn: 'สุ่มเลย!',
                listTitle: 'รายการ Pokemon',
                backBtn: 'กลับไปหน้าค้นหา',
                height: 'ความสูง',
                weight: 'น้ำหนัก',
                abilities: 'ความสามารถ',
                stats: 'ค่าสถานะ'
            }
        }
    },
    en: {
        nav: {
            title: 'Next.js Learn',
            subtitle: 'Interactive TypeScript Course',
            home: 'Home',
            variables: 'Variables (Const/Let)',
            state: 'State (useState)',
            effects: 'Effects (useEffect)',
            fetch: 'Fetching (Fetch API)',
            axios: 'Fetching (Axios)',
            routing: 'Routing (Dynamic)',
            rsc: 'Server vs Client',
            serverActions: 'Server Actions',
            context: 'Global State (Context)',
            cssLayout: 'CSS Layout (Flex/Grid)',
            cssResponsive: 'Responsive Design',
            cssAnimation: 'Animations & Styling',
            stateRedux: 'State: Redux Toolkit',
            stateZustand: 'State: Zustand',
            workshopPokemon: 'Workshop: Pokedex',
        },
        home: {
            title: 'Welcome to Next.js Learning',
            subtitle: 'This is a hands-on interactive guide to mastering Basic Next.js and TypeScript concepts. Navigate through the lessons on the left or select a topic below to get started.',
            start: 'Start Lesson',
            topics: [
                {
                    title: "Variables",
                    desc: "Understand const vs let and type inference.",
                },
                {
                    title: "State Management",
                    desc: "Learn how to use useState for interactivity.",
                },
                {
                    title: "Side Effects",
                    desc: "Master useEffect for lifecycle events.",
                },
                {
                    title: "Fetch API",
                    desc: "Native data fetching in Next.js.",
                },
                {
                    title: "Axios",
                    desc: "Powerful fetching with the Axios library.",
                },
                {
                    title: "Routing & Dynamic Routes",
                    desc: "Create pages using file-system structure.",
                },
                {
                    title: "Server vs Client Components",
                    desc: "Understand the difference between Server and Client environments.",
                },
                {
                    title: "Server Actions",
                    desc: "Modern form handling without API routes.",
                },
                {
                    title: "Global State (Context)",
                    desc: "Manage shared data across the app.",
                },
                {
                    title: "CSS Layouts (Flex & Grid)",
                    desc: "Master layout control with Flexbox and CSS Grid.",
                },
                {
                    title: "Responsive Design",
                    desc: "Build mobile-first websites that work on any device.",
                },
                {
                    title: "Animations & Styling",
                    desc: "Add life to your app with smooth transitions and animations.",
                },
                {
                    title: "Redux Toolkit",
                    desc: "The industry standard for complex state management.",
                },
                {
                    title: "Zustand",
                    desc: "Simple, scalable state management without providers.",
                }
            ]
        },
        lessons: {
            variables: {
                title: 'Variables: const vs let',
                intro: 'In Modern JavaScript (ES6+) and TypeScript, we rarely use var. Instead, we use const and let.',
                constTitle: '1. The const Keyword',
                constDesc: 'const stands for "constant". It means the variable identifier cannot be reassigned. Use it for values that won\'t change.',
                constError: '❌ This will cause an error: Assignment to constant variable.',
                letTitle: '2. The let Keyword',
                letDesc: 'Use let when you need to reassign a variable later, such as in loops or mathematical operations.',
                typeTitle: '3. TypeScript & Type Inference',
                typeDesc: 'TypeScript is smart. You often don\'t need to specify types explicitly if you initialize the variable immediately. This is called Type Inference.',
                currentVal: 'Current Value of demoConst:',
                increment: 'Increment',
                stateSim: 'Current Value (useState):',
                letVsStateTitle: 'Why let does not update the UI?',
                letVsStateDesc: 'Try clicking "Update let". The Console value changes, but the screen does not. React does not know it needs to re-render.',
                letBtn: 'Update let (Check Console)',
                stateBtn: 'Update State (UI Changes)',
            },
            state: {
                title: 'State Management: useState',
                intro: 'State is the memory of your component. When state changes, React re-renders the component to reflect the new data.',
                basicTitle: 'Basic State (Number)',
                inputTitle: 'Input Binding (String)',
                complexTitle: 'Complex State (Objects)',
                complexDesc: 'When updating objects, you must copy the existing properties using the spread operator ...',
                placeholder: 'Type something...',
                youTyped: 'You typed:',
                updateName: 'Update Name',
                arrayTitle: 'Managing Arrays in State',
                arrayDesc: 'Never use .push()! Use Spread Operator (...) to create a new array instead.',
                arrayWarning: '⚠️ Wrong (No Render):',
                arrayCorrect: '✅ Correct (Render):',
                btnAdd: '+ Add',
                btnPop: '- Pop',
                btnFilter: 'Remove Index 1'
            },
            effects: {
                title: 'Side Effects: useEffect',
                intro: 'useEffect acts like a "caretaker" that performs tasks when the Component mounts, updates, or unmounts. Use it for data fetching, timers, or external subscriptions.',
                timerTitle: '1. Dependencies & Logic (Timer Example)',
                timerDesc: 'This Effect "re-runs" every time the values in [ ] change (here, isRunning). When isRunning is true, it sets up an interval.',
                cleanTitle: '2. The Cleanup Function (Critical!)',
                cleanDesc: 'React calls the returned function when the Effect is destroyed or before re-running it. It is used to "clean up" leftovers like clearInterval or removeEventListener.',
                startTimer: 'Start Timer',
                pauseTimer: 'Pause Timer',
                mousePos: 'Mouse Position',
                moveMouse: 'Move your mouse around the screen. The event listener is active thanks to useEffect.',
                realWorldTitle: 'Real World Use Cases',
                autoSaveTitle: 'A. Auto-Save (with Debounce)',
                autoSaveDesc: 'useEffect runs on every keystroke. We use setTimeout to wait for you to stop typing (1s delay). If you type again, the old Effect cleans up, and the timer restarts.',
                typing: 'Typing...',
                saving: 'Saving...',
                saved: 'Saved at',
                exchangeTitle: 'B. Data Syncing (Currency Converter)',
                exchangeDesc: 'Whenever the selected currency changes (dependency updates), the Effect runs immediately to fetch the new rate.',
                rate: 'Exchange Rate'
            },
            fetch: {
                title: 'Data Fetching: Native Fetch API',
                intro: 'Next.js allows you to fetch data on the server or client. Here we demonstrate client-side fetching with the native fetch API.',
                patternTitle: 'Client-Side Fetch Pattern',
                patternDesc: 'A standard pattern involves 3 states: loading, error, and data.',
                liveDemo: 'Live Demo',
                fetchBtn: 'Fetch Users',
                fetching: 'Fetching...',
                loading: 'Loading data...',
                clickToLoad: 'Click the button to load data',
                error: 'Error:',
            },
            axios: {
                title: 'Data Fetching: Axios',
                intro: 'Axios is a popular HTTP client that simplifies requests. It supports older browsers, request cancellation, and automatic JSON parsing.',
                vsTitle: 'Axios vs Fetch',
                features: [
                    'Automatic JSON transform: No need for response.json()',
                    'Better Error Handling: Rejects promises on HTTP 4xx/5xx automatically',
                    'Interceptors: Easy way to attach tokens globally',
                ],
                demoTitle: 'Axios Demo',
                fetchBtn: 'Get Posts',
                clickToLoad: "Click 'Get Posts' to fetch data via Axios",
            },
            routing: {
                title: 'Routing: File-System Based',
                intro: 'Next.js uses the file system to define routes. Folders in `app` automatically become URL paths.',
                basicsTitle: 'Routing Basics',
                basicsDesc: '`page.tsx` is the UI for a route. `layout.tsx` is shared UI for a segment.',
                dynamicTitle: 'Dynamic Routes [id]',
                dynamicDesc: 'Use square brackets `[id]` to create a route that accepts dynamic values like `/blog/1`.',
                demoTitle: 'Dynamic Route Demo',
                clickToTest: 'Click to test links:',
                product: 'Product'
            },
            rsc: {
                title: 'Server vs Client Components',
                intro: 'In Next.js (App Router), every component is a Server Component by default, unless you declare `use client`.',
                serverTitle: 'Server Component (Default)',
                serverDesc: 'Runs only on the Server. Great for fetching data/tokens. Logic is never sent to the client (smaller bundle).',
                clientTitle: 'Client Component',
                clientDesc: 'Use when you need interactivity (useState, useEffect, onClick). Must verify with "use client" at the top.',
                demo: 'Live Demo',
                serverLog: 'This logs in the Server terminal',
                clientLog: 'This logs in the Browser console',
            },
            serverActions: {
                title: 'Server Actions',
                intro: 'A modern way to handle form submissions. Write functions that run on the server and call them directly from `form action`.',
                formTitle: 'Server Action Form',
                desc: 'Submit the form below. The data is processed on the server magically.',
                label: 'Message to Server:',
                btn: 'Send Data',
                placeholder: 'Type a message...',
                success: 'Server says: '
            },
            context: {
                title: 'Global State (Context API)',
                intro: 'When you need to share data across many components (Auth, Theme, Language), use the Context API.',
                desc: 'The best example is the Language Switcher you are using right now! It uses a Context Provider wrapping the app.',
                demoTitle: 'Context Demo (User)',
                login: 'Login (Simulated)',
                logout: 'Logout',
                welcome: 'Welcome, '
            },
            cssLayout: {
                title: 'Layout Masters: Flexbox & Grid',
                intro: 'The heart of web layout is Flexbox (1D) and Grid (2D). Tailwind makes these super intuitive.',
                flexTitle: 'Flexbox (Alignment)',
                flexDesc: 'Use `flex` to align items horizontally or vertically. Center content easily with `items-center` and `justify-center`.',
                gridTitle: 'CSS Grid (2D Layout)',
                gridDesc: 'Use `grid-cols-3` to split space into equal columns. Perfect for galleries and dashboards.',
                demoItem: 'Box'
            },
            cssResponsive: {
                title: 'Responsive & Mobile First',
                intro: 'Tailwind uses a Mobile First approach. You style for mobile by default, then add `md:` or `lg:` for larger screens.',
                breakpointsTitle: 'Breakpoints',
                breakpointsDesc: 'Resize your browser window to see the box below change color and size.',
                mobile: 'Mobile (Default)',
                tablet: 'Tablet (md)',
                desktop: 'Desktop (lg)',
                demoBox: 'I change size!'
            },
            cssAnimation: {
                title: 'Animations & Styling',
                intro: 'A good website must feel "alive". Adding transitions and micro-animations makes your app feel premium.',
                hoverTitle: 'Hover & Transition',
                hoverDesc: 'Use `transition-all` and `hover:scale` to create fluid interactions when mouse hovers.',
                pulseTitle: 'Keyframe Animations',
                pulseDesc: 'Tailwind includes built-in animations like `animate-bounce` and `animate-pulse` for loading states.',
                btnHover: 'Hover Me!',
                loading: 'Loading...'
            },
            stateRedux: {
                title: 'Redux Toolkit & React Redux',
                intro: 'Redux is the industry standard custom state management. We use it with React Redux bindings.',
                concept: 'Flux Pattern',
                conceptDesc: 'Store (Data) -> Action (Instruction) -> Reducer (Processor) -> New State',
                pros: [
                    'Predictable changes',
                    'Powerful DevTools (Time Travel)',
                    'Strict structure scales well'
                ],
                cons: [
                    'Lots of boilerplate code',
                    'Requires Provider wrapper around app',
                    'Steep learning curve'
                ],
                demoTitle: 'Example 1: Real Code (RTK + Store)',
                demoDesc: 'Implementing a real Slice and Store, wrapping with <Provider>, and using useSelector / useDispatch.',
                value: 'Current Value:',
                inc: 'Increment',
                dec: 'Decrement',
                reset: 'Reset',
                globalTitle: 'Example 2: Global User State',
                globalDesc: 'Simulating User Slice where display and edit components are separated, proving the "Global" nature of the state.',
                cardTitle: 'User Card',
                editTitle: 'Edit Profile',
                userName: 'Username',
                userRole: 'Role',
                updateProfile: 'Update Profile',
                note: '* Observation: When Component A updates, Component B reflects changes instantly without props.'
            },
            stateZustand: {
                title: 'Zustand',
                intro: 'Zustand (German for "State") is trending heavily. It is simple, lightweight, and provider-less.',
                concept: 'How it works',
                conceptDesc: 'Create a Store as a Hook, and use it anywhere. No Provider needed!',
                pros: [
                    'Minimal boilerplate',
                    'No Context Provider required',
                    'Renders only what changes (Performant)'
                ],
                cons: [
                    'Can be too flexible (needs discipline)',
                    'Smaller community than Redux'
                ],
                demoTitle: 'Zustand Store Demo',
                demoDesc: 'Imagine we have a global store counting "Bears" in a forest.',
                bears: 'Bears',
                addBear: 'Add Bear',
                removeBear: 'Remove Bear',
                clear: 'Clear'
            },
            workshopPokemon: {
                title: 'Workshop: Pokedex App',
                intro: 'This lesson combines everything: State, Effect, Axios, and complex data handling to build a Pokemon Search App.',
                searchTitle: 'Search Pokemon',
                searchDesc: 'Use Axios to fetch data from PokeAPI by name or ID.',
                placeholder: 'Enter name or ID (e.g. charizard, 6)',
                searchBtn: 'Search',
                randomBtn: 'Random!',
                listTitle: 'Pokemon List',
                backBtn: 'Back to Search',
                height: 'Height',
                weight: 'Weight',
                abilities: 'Abilities',
                stats: 'Stats'
            }
        }
    }
};
